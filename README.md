# Algorithems
C++ Implementation of Classical Algorithms 

## 1.排序算法

| 算法     | 时间复杂度     | 空间复杂度 | 稳定性 |
| -------- | -------------- | ---------- | ------ |
| 冒泡排序 | O($n^2$)       | O($1$)     | 是     |
| 选择排序 | O($n^2$)       | O($1$)     | 否     |
| 插入排序 | O($n^2$)       | O($1$)     | 是     |
| 希尔排序 | O($nlogn$)     | O($1$)     | 否     |
| 归并排序 | O($nlogn$)     | O($n$)     | 是     |
| 快速排序 | O($nlogn$)     | O($logn$)  | 否     |
| 堆排序   | O($nlogn$)     | O($1$)     | 否     |
| 计数排序 | O($n+k$)       | O($k$)     | 是     |
| 桶排序   | O($n+k$)       | O($n+k$)   | 是     |
| 基数排序 | O($n\times k$) | O($n+k$)   | 是     |

- 冒泡排序

> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

- 选择排序

> 不断从未排序序列中找最大元素，放到序列的起始位置

- 插入排序

> 待排序元素前面的序列有序，后面的无序，不断将元素插入到有序序列相应的位置

- 希尔排序

> 插入排序的一种更高效的改进版本
>
> 按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 $t_i$，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

- 归并排序

> 分治法的典型应用
>
> 将待排序序列一分为二，分别有序后进行合并
>
> 一分为二的过程递归下去

- 快速排序

> 选择一个元素为基准
>
> 从序列两端进行遍历，左侧找到大于基准的数，右侧找到小于基准的数，交换位置，直到左右两侧相遇
>
> 此时左区间全小于基准，右区间全大于基准
>
> 继续对两个区间排序

- 堆排序

> 将序列创建为堆：从下往上遍历，dad小于son则交换
>
> 将堆顶端的元素与最后的元素交换，重新构造堆，不断重复

- 计数排序

> 统计数组中每个元素出现次数，根据计数结果进行填充

- 桶排序

> 将元素尽量均分到不同的桶
>
> 每个桶的元素分别排序，之后合并

- 基数排序

> 先按照个位排序，再按照十位，百位...

